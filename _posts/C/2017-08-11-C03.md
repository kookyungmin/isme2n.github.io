---

layout: post

title:  "[C언어] 2. C언어 정리(2)"

subtitle: "[C언어] 2. C언어 정리(2)"

date:   2017-08-11 09:00:01 -0500

categories: Study

tags: C

---


<br>
<br>
제가 책(윤성우의 열혈 C 프로그래밍)을 보다가 까먹었던 부분만 포스팅 하는 것입니다!
<br>
<br>
순서가 뒤죽박죽이어도 이해해주세요~~!
<br>
<br>

## static 변수

<br>
<br>


지역변수에 static 선언이 붙게되면, 이는 전역변수의 성격을 지니는 변수가 됩니다.
<br>
<br>
원래 지역변수는,
<br>
<br>
1. 선언된 함수 내에서만 접근이 가능하고,
<br>
2. 함수 내에 선언된 지역변수는 해당 함수가 반환하면 소멸됩니다.

<br>
<br>
그런데 함수 내에 선언된 지역변수에 static 선언이 붙게되면,
<br>
<br>
1. 선언된 함수 내에서만 접근이 가능하고(지역변수 특성)
<br>
2. 딱 1회 초기화되고 프로그램 종료 시까지 메모리 공간에 존재하게 됩니다.

<br>
<br>
선언은 다음과 같습니다~
<br>
<br>

``` cpp
static int num=0;
```

<br>
<br>

그리고 static으로 선언된 지역변수는 함수가 호출되어야 선언되는 것이 아니라
<br>
전역변수처럼 프로그램 시작과 동시에 할당 및 초기화되어 프로그램이 종료할 때까지 메모리 공간에 남아 있습니다.

<br>
<br>

## NULL 

<br>
<br>

```
문자열의 마지막엔 항상 NULL문자를 삽입하여야 합니다. (NULL문자가 없으면 문자배열)

NULL문자의 아스키코드는 0 입니다.

NULL 포인트도 0 입니다.
```

<br>
<br>

## 두가지 형태의 문자열 표현
<br>
<br>

문자열의 선언은 두 가지가 있습니다.
<br>
<br>
변수형태의 문자열 선언
<br>

``` C++
char str1[]="My String";
```

<br>
<br>
상수형태의 문자열 선언
<br>
<br>

``` cpp
char *str2="Your String";
```

<br>
<br>
배열이름이 포인터이기에 str1은 문자열의 처음 문자인 M의 주소 값을 가지고 있습니다.
<br>
str2도 문자열의 처음 문자인 Y의 주소 값을 가지고 있습니다.
<br>
<br>
그러나 str2는 다른 문자열을 가리키게 변경할 수 있지만, str1는 변경할 수 없습니다.
<br>
그리고 str1은 str1[0]으로 문자 하나하나에 접근 가능하지만, str2는 접근 할 수 없습니다

<br>
<br>

## 포인터 배열
<br>
<br>

포인터 변수로 이뤄진, 그래서 주소 값의 저장이 가능한 배열을 가리켜 '포인트 배열'이라고 합니다.
<br>
<br>
선언은 다음과 같습니다
<br>
<br>

```cpp
int* arr[10];
```

<br>
<br>
포인터 각각은 배열이름으로 사용될 수 있기에, 포인터배열은 배열들을 다루기에 용이합니다.
<br>
<br>
문자열을 저장하는 포인터 배열
<br>
<br>

```cpp
char * str="hello"; //char형 포인터는 문자열을 저장 가능


char * strArr[3]={"simple","string","array"}; //char형 포인터배열은 문자열들을 저장
```

<br>
<br>

## 배열을 함수의 인자로 전달받는 방법
<br>
<br>

배열은 Call-by-refernce 방식으로 함수의 인자로 전달해야하죠~
<br>
<br>
그 방법은 두 가지 입니다.
<br>
<br>

```cpp
void function(int *arr,int len);

void function(int arr[],int len); //더 자주 사용
```

<br>
<br>
배열의 주소 값을 인자로 전달받는 매개변수는 포인터 변수이기 때문에,
<br>
이를 대상으로 sizeof 연산을 할 경우 배열의 크기가 반환되지 않고 
<br>
포인터 변수의 크기가 반환됩니다.
<br>
<br>
이렇듯 함수 내에서는 인자로 전달된 배열의 길이를 계산할 수 가 없기 때문에, 
<br>
배열의 길이도 같이 인자로 전달해야 합니다.


<br>
<br>

## 포인터 대상의 const 선언
<br>
<br>

포인터가 가리키는 값을 상수화 할 때,
<br>
<br>

```cpp
const int *ptr=&num;
*ptr=40; //컴파일 에러
```

<br>
<br>
포인터를 상수화 할 때,
<br>
<br>

```cpp
int *const ptr=&num;
ptr=&num2; //컴파일에러
```

<br>
<br>
둘다 상수화 할 때
<br>
<br>

```cpp
const int *const ptr=&num;
```

