---

layout: post

title:  "[IoT_응용SW기초] 9.데이터통신 기초(4)"

subtitle: "[IoT_응용SW기초] 9.데이터통신 기초(4)"

date:   2018-05-10 09:00:20 -0500

categories: IoT_Curriculum

tags: basis

---

## OSI 7 계층 모델

<br>
<br>

>저번 장에서 배운 OSI 7계층 모델 물리 계층에 이어서 나머지 계층에 대한 설명을 포스팅하겠습니다!

<br>
<br>

## 데이터링크 계층

<br>
<br>

```
<데이터링크 계층>


데이터링크 계층은 데이터 패킷을 생성하고 전송하는 방법을 규정하는 프로토콜에 대한 계층이다.


이 계층이 하는 일은 물리 계층에서 넘어오는 데이터의 오류를 검사하고 복구하는 기능을 담당할 뿐만 아니라,


시스템 간 전송 속도 차에 의한 오류나 흐름제어까지 도맡아 처리한다.


쉽게 말해 화물을 트럭에 싣고, 각 트럭을 고속도로로 보내어 화물이 무사히 도착하도록
관리하는 역할을 담당한다.
```

<이 계층에 속하는 네트워크 연결 장비>


브리지, 지능형 허브


데이터링크 계층의 여러 기능은 


대개 MAC(Media Access Control), LLC(Logical Link Control) 두 가지로 세분화된다.


MAC 계층은 동일 채널을 공유하는 통신 방법을 제어하기 위한 것이고,


LLC 계층은 데이터 전송을 위해 각 장비들을 논리적으로 연결하고, 연결을 유지하는 역할을 담당한다.
```

<br>
<br>
<br>

![image](/image/IoT_image/IoT_img_25.png)

<br>
<br>
<br>

```
<물리적 토폴로지와 논리적 토폴로지>


네트워크 장비들은 데이터를 네트워크의 논리적인 토폴로지에 따라 전송한다.


물리적인 토폴로지는 매체 혹은 데이터 경로의 구조를 의미하지만,


몇몇 특수한 경우는 네트워크의 물리적인 데이터 전달 경로와 다를 수 있다.


그러한 전달 경로를 논리적 토폴로지라고 한다.


ex) IBM의 토큰링 네트워크


토큰링 방식은 종종 중앙의 허브와 네트워크 장비 연결 시에 케이블을 이용한 스타형 토폴로지로 한다.


이 때 허브는 일반적인 스타형 토폴로지처럼 신호를 모든 장비에 재전송하기 위한 것이 아니라,


미리 정해진 순서에 따라 순환적으로 신호를 받고 다음 장비에 전송한다.


따라서 물리적 구조는 스타형 토폴로지지만 논리적인 구조는 링형 토폴로지라고 말할 수 있다.
```

<br>
<br>
<br>

![image](/image/IoT_image/IoT_img_26.png)

<br>
<br>
<br>

```
<신호 전송 통제>


논리적 토폴로지는 네트워크 장비가 신호 전송을 통제하기 위해 특별한 기법을 사용하는데, 


이런 통제 절차를 매체 액세스라고 한다.


예를 들어, 네트워크에 연결된 모든 장비가 통제받지 않고 마음대로 신호를 전송한다면,


여러 네트워크 장비가 동시에 신호를 전송할 경우에 신호들이 서로 섞이고 변형되어 제대로 
데이터를 전송할 수 없게된다.


이런 경우를 충돌이라 하는데, 충돌이 발생하면 효과적인 데이터 전송이 불가능하다.


따라서 네트워크 시스템은 충돌을 줄이거나 동시에 전송되는 신호 간 상호 간섭을 줄여야 한다.


신호의 충돌을 줄이기 위해 네트워크 장치들이 전송 시점을 결정하는 방법인 매체 액세스 방법에는


경쟁, 토큰 패싱, 폴링 등이 있다.
```

<br>
<br>
<br>

```
<경쟁 시스템>


경쟁 시스템은 먼저 요구하거나 이미 신호를 전송중인 네트워크 장비에 우선권을 부여하는 방법이다.


충돌에 의한 데이터 손실은 불가피하며, 새로운 장비가 네트워크에 추가될 때마다 효율도 점점 낮아진다.


이런 충돌을 줄이기 위해 새로운 경쟁 프로토콜을 정한 뒤 전송하기 전에 전송할 채널을 사용할 수 있는지
검사해야 한다.


만약 다른 장비의 신호가 전송 중에 있으면 전송을 보류하고 잠시 후에 다시 시도한다.


이런 방법을 CSMA(Carrier Sense Multiple Access) 프로토콜이라고 하는데,


여기에는 CSMA/CD(Carrier Sense Multiple Access/Collsion Detection),


CSMA/CA(Carrier Sense Multiple Access/Collsion Avoidance)의 두 가지 방식이 있다.


CSMA/CD : 전송 전에 케이블을 검사하고 충돌이 발생하는지 확인한 다음,


충돌이 있으면 재전송을 시도한다. 


ex) 이더넷, IEEE 802.3


CSMA/CA : 시분할 액세스나 매체에 액세스하기 전에 요구하는 방식을 사용한다. (충돌을 회피하는 방법)
```

<br>
<br>
<br>

```
<토큰 패싱 시스템>


토큰이라는 일련의 작은 데이터를 순차적으로 한 장비에서 다른 장비로 전달하는 시스템


토큰은 그것을 전달받은 장비에게 통신 권한을 부여하는 특별한 네트워크 메시지로,


분산된 네트워크 장비들에게 차례차례 토큰을 부여함으로써 전송 권한을 공유한다.


디지털 음성이나 비디오 같이 시간에 민감한 네트워크나 사용자가 많은 네트워크에 적합
```

<br>
<br>
<br>

```
<폴링 시스템>


중앙의 매체 사용 관리자로부터 사용 권한을 받아서 동작하는 방식을 말한다.


미리 정해진 순서에 의해 각 장비가 전송할 데이터가 있는지 검사하고 사용 권한을 부여한다.


중앙 장치는 단말 장비로부터 데이터를 얻기 위해 데이터를 전송하라는 명령을 장비로 보내고 데이터를 수신한다.


그 후 다른 단말기에 대해서도 데이터로 전송할 것을 요구하는데,


한 번에 전송할 수 있는 데이터의 양은 프로토콜로 정해준다. 


폴링 시스템은 자동화 장비처럼 지연 시간에 민감한 시스템에 적합하다.


한편, 중앙 장치가 단말 장치로 데이터를 전송하고자 할 경우, 단말 장치의 상태를 확인하는 것을 셀렉팅이라고 한다.
```

<br>
<br>
<br>

```
<어드레스 지정>


네트워크에 연결된 컴퓨터는 각각 서로를 구별할 수 있어야 하며, 이를 위한 방법이 필요하다.


이렇게 서로를 구분하는 과정을 어드레스 지정(addressing)이라고 한다.


어드레스 지정은 네티워크 시스템의 각 장비마다 고유의 어드레스와 이름을 설정해줌으로써


하드웨어나 소프트웨어로 장비를 식별하기 위한 방법이다.


데이터링크 계층은 오직 물리적인 장비의 어드레스(MAC address)만을 취급한다.


물리적인 장비의 어드레스는 하드웨어 제작자가 각자의 장비에 부여한 고유 번호이다.
```

<br>
<br>
<br>

```
<전송 동기화>


송신기가 자신이 전송할 시기를 정확히 알고 있어야 하듯이 수신기도 언제 수신받는 데이터가 끝나는지 
알고 있어야 한다.


물리 계층에 속하는 이진 신호 전달을 위한 동기화 방식은 단지 신호를 검출하는 통신 시차를 줄이기 위한 것이다.


컴퓨터 통신의 경우, 이런 이진 신호를 묶어 문자 단위나 바이트 단위,
프레임 단위로 전송한다.


물리적인 이진 동기와 더불어 네트워크 장비들은 프레임 통신을 할 수 있어야한다.


프레임 전송을 조정하기 위한 방법으로는 비동기, 동기, 등시간 동기 등의 방식이 사용된다.
```

<br>
<br>
<br>

```
<비동기 전송>


비동기 전송 방식은 네트워크 장비 내부의 클럭 장치를 통해 이뤄진다.


두 장비 내부의 클럭 장치는 비슷한 시차 간격으로 동작하기는 하지만,


그 클럭 장치가 동기화된 상태는 아니다.


비동기 방식은 비동기식 비트 동기 방식을 이용해 한 프레임씩 따로따로 전송한다.


각 프레임(이진 신호)은 시작 신호로 시작하고, 데이터를 전송한 후에는 신호를 계속 전송하지 않아도 된다.


비교적 짧은 비트 열을 사용하므로 수신 장치가 시작 신호를 읽지 못해 동기를 맞추지 못하는 일은 거의 없다.


비동기 방식은 비교적 단순하지만 전송 오류가 종종 발생하기 때문에 전송 오류를 검사하기 위한 


패리티 비트를 프레임 뒤에 추가해야 한다.


이 패리티 검사 방식의 문제점은 다수의 비트가 변형됐을 경우 오류 검출에 실패할 가능성이 있다는 것이다.
```

<br>
<br>

![image](/image/IoT_image/IoT_img_27.png)

<br>
<br>
<br>

```
동기 전송시에 전송 동기를 맞춰주는 동기 기법이 필요하다. 여기에는 특별한 비트열을 전송하거나,


하나 또는 그 이상의 특별한 문자(SYN SYNC)를 전송하는 방법과 별도의 채널로 동기 신호를


따로 전송하는 방법이 있다.


두 가지 방법 모두 바이트 또는 프레임의 시작을 알리기 위해 동기 바이트나 프레임을 사용한다.


수신기에서는 이런 방식을 통해 언제부터 데이터를 검출하기 시작해야 하는지 판단할 수 있다.


그리고 비동기 방식과 마찬가지로 동기 전송 방식에서도 오류 검출을 수행한다.


여기에는 CRC(Cyclic Redundancy Check) 방식이 많이 사용된다.


CRC 방식은 데이터를 일정한 묶음 단위로 계산해, 그 결과값이 전송되는 데이터 묶음에 추가된다.


수신기에선 같은 계산 방법으로 수신된 데이터의 CRC를 계산하고 수신된 CRC와 같은지 검사한다.


CRC 방식은 비동기 방식의 패리티 검사 방식에 비해 전송 비트가 잘못됐더라도 정확하게 오류를 검출할 수 있다.
```

<br>
<br>
<br>

![image](/image/IoT_image/IoT_img_28.png)

<br>
<br>
<br>

```
<등시간 동기 전송>


등시간 동기 전송은 항시적인 일정 주파수의 전송 클럭을 사용해 타임 슬롯을 생성하는 방식이다.


이 때 동기 신호는 특정 장비에 의해 만들어지며, 모든 네트워크 장비에 전달된다.


매체 액세스 방식과 마찬가지로 각 네트워크 장비는 동기 신호를 검사하고 데이터가 없는 영역에


자신의 데이터를 실어 보낸다.
```

<br>
<br>
<br>

```
<연결서비스>


1. 수신 미확인 비연결형 서비스


프레임의 전송과 수신 시에 전송 순서, 오류, 패킷의 순서 제어를 하지 않는다.


2. 연결형 서비스


전송 순서, 오류, 패킷 순서의 전송 제어 기능을 제공한다.


3. 수신 확인 비연결형 서비스


일대일 연결 방식에서 전송 순서나 오류 제어 기능을 제공한다.


연결 서비스는 수신을 확인하기 위한 특별한 프레임인 수신확인(ACK)를 사용한다.


수신 확인을 위해서는 LLC-단계 흐름 제어나 오류제어와 같은 데이터링크 -LLC 계층 연결서비스를 실행한다.


이때 데이터링크 LLC 계층 연결 서비스는 데이터의 손실을 막기 위해 컴퓨터 간에 한 번에 전송되는


데이터의 양을 제어하고 전송 오류를 검출함으로써 재전송을 요구하는 등의 기능을 제공한다.
```

<br>
<br>
<br>

```
<LLC-단계 흐름 제어>


일단, 두 네트워크 장비가 연결되고 나면 얼마나 많은 데이터를 주고받을 것인지가 중요한 과제로 남는다.


일반적으로 네트워크는 서로 다른 전송 속도와 용량을 가진 장비들로 구성돼 있다.


느린 수신기에 빠른 전송을 시도하여 데이터가 손실되는 것을 방지하기 위해 흐름 제어를 사용하며,


일정 시간 내에 전송될 수 있는 데이터의 양을 제어한다.


LLC-흐름제어는 빠른 기계가 느린 기계와 별 무리없이 작동할 수 있도록 해주며,


컴퓨터 등의 단말기와 리피터 등의 연결 장비에도 쓰인다.


흐름제어는 윈도우 흐름 제어와 보장 흐름 제어의 두 가지 방식으로 나누어진다.
```

<br>
<br>
<br>

```
<윈도우 흐름 제어>


정적 또는 동적인 방식으로 일정 개수의 프레임이 들어갈 수 있는 버퍼나 윈도우를 관리하는 것이다.


정적 윈도우 흐름 제어: 일정한 크기의 윈도우를 사용하는 방식이다.


만일 원도우의 크기가 프레임 7개로 정해졌다면 송신기는 여러 가지 데이터 프레임을 수집하고


각 프레임에 내부 번호를 부여해줄 뿐 아니라 프레임 전송까지 도맡아 수행한다.


동적 윈도우 흐름 제어: 네트워크 장비들이 윈도우 크기를 조정해줌으로써 더욱 효율적인 전송을 꾀하는 방식이다.


플로팅/슬라이딩 윈도우 흐름 제어라고도 불리는 이 방식은 수신기에 따라 윈도우를 설정해 프레임의 개수를 결정한다.]


만일 수신기의 수신 용량이 다 차게 되면 쐐기 패킷을 송신기에 전달해 송신 속도를 늦추도록 요구한다.
```

<br>
<br>
<br>

```
속도 보장 흐름 제어>


데이터 전송 전에 설정된다. 송신기와 수신기는 서로 간에 적당한 수신 속도를 미리 설정해야 하는데, 


이 속도는 전송이 끝날 때까지 보장된다.
```

<br>
<br>
<br>

```
<오류 제어>


LLC-단계 오류 제어는 프레임의 손실과 손상을 검출하고 알리기 위해 사용되며,


수신기가 패킷 수신에 실패했을 경우나 합계 검사값이 맞지 않을 경우에 수행된다.


송신 측 응용프로그램이 수신 확인을 받지 못했거나 부정으로 수신 확인을 받으면,


송신 측은 오류가 발생한 것으로 가정하고 재전송을 시도한다.
```

<br>
<br>

## 네트워크 계층

<br>
<br>

```
<네트워크 계층>


네트워크 계층은 여러 개의 독립적인 네트워크 중 데이터 전송에 관한 계층이다.


앞서 설명한 데이터링크 계층의 데이터 전송은 물리적인 장치의 어드레스 지정을 통해


단일 네트워크로 연결된 모든 장치에 데이터를 브로드캐스팅하며,


수신 측 장비에서 확인한 뒤 자신에게 오는 데이터를 수신받는 방식이다.


그러나 네트워크 계층에서는 네트워크와 네트워크를 연결하는 인터네트워크환경에서


특정 경로를 선택함으로써 권한이 없는 네트워크에 데이터가 전송되는 것을 미연에 방지할 수 있다.


즉, 네트워크 계층에서는 서로 다른 네트워크로 구성된 인터네트워크를 통해


올바른 데이터 경로를 보장할 수 있다.


네트워크 계층에서는 기본적으로 다음과 같은 사항을 수행하게 된다.
>```

<br>
<br>
<br>

![image](/image/IoT_image/IoT_img_29.png)

<br>
<br>
<br>

```
<어드레스 지정>


서비스 요청자와 제공자는 인터네트워크 상에서 각각의 구성 요소를 구분할 수 있어야 한다.


이런 구별은 어드레스를 통해 이뤄지는데, 컴퓨터는 개별, 로컬, 광역 등의 등급에 따라 이름이나 번호가 부여된다.


상대방과 서로 통신을 하고자 하는 네트워크 구성 요소들은 특정한 어드레스를 참조할 수 있어야 한다.
```

<br>
<br>

```
<논리적인 네트워크 어드레스>


인터네트워크 환경에서 데이터를 전송하기 위해서는 논리적인 네트워크 어드레스를 사용해야 한다.


논리적인 네트워크 어드레스는 인터네트워크 환경에서 각각의 네트워크를 논리적으로 구분할 때


사용되는 식별자에 해당한다.


라우터는 논리적인 네트워크 어드레스가 서로 다른 두 개의 네트워크를 연결하는 


인터네트워크 장비로, 데이터를 어디에 전송해야 할지를 각 데이터 패킷의 네트워크 어드레스에


기초해 경로 발견과 경로 선택 방법을 사용해서 알아낸다.
```

<br>
<br>
<br>

```
<서비스 어드레스>


인터네트워크 환경에서 장치들 간에 데이터를 이동시키기 위해서는 물리적인 어드레스와


논리적인 네트워크 어드레스를 함께 사용해야 한다.


그러나 각각의 컴퓨터나 네트워크로 연결된 장비들은 몇 가지 역할을 동시에 수행 할 수 있다.


이 때 각각의 하드웨어나 소프트웨어마다 별도의 어드레스를 갖고 있어야 한다. 


이 어드레스를 서비스 어드레스라고 한다.


서비스 어드레스를 통해 특정한 상위 계층 소프트웨어 프로세스나 프로토콜의 식별이 가능하다.


하나 이상의 네트워크 애플리케이션이 실행되고 있는 컴퓨터에 대해서는 각각의 애플리케이션마다 


서비스 어드레스를 할당할 수 있다.
```

<br>
<br>
<br>

![image](/image/IoT_image/IoT_img_30.png)

<br>
<br>
<br>

```
<교환>


대형 인터네트워크는 여러 개의 전송 장치와 수신 장치를 연결하는 복수의 경로로 구성될 수 있다.


철길에서 선로를 바꾸는 것과 유사한 방식으로 정보도 여러 가지 통신 채널을 지나는 동안에


교환될 수 있다.


데이터 교환 방식에는 회선교환, 메시지 교환, 패킷 교환 등이 있다.
```

<br>
<br>
<br>

```
<회선 교환>


회선 교환은 통신이 지속되는 기간 동안 전송 측과 수신 측을 하나의 경로로 연결하는 기법이다.


전화를 예로 들면, 


전화 교환 장치는 번호를 이용해 발신 측 전화와 수신 측 전화 간에 경로를 구축한다.


컴퓨터 네트워크에서 회선 교환은 전화와 매우 유사한 방식이며,


통신이 이뤄지기에 앞서 종단 간에 경로가 만들어져야 한다.


따라서 데이터 전송을 개시하기 전에 수신 측까지 연결이 되었는지를 먼저 확인해야 하며,


연결이 이뤄지면 수신 측 장비는 전송을 수행할 준비가 됐음을 알린다.
```


<br>
<br>
<br>

```
<메시지 교환>


메시지 교환 방식은 메시지별로 통신을 수행하는 방식이다. 


각각의 메시지가 수신 측 어드레스와 함께 패킷화된 후 네트워크를 통해 전송된다.


이 때 중간에 위치한 장비들은 메시지를 수신하고 잠시 저장한 후 다음 장비로 전송한다.


이런 유형의 네트워크를 축적 전송 방식 네트워크라고도 부른다.


일반적으로 메시지 교환 장치는 범용 컴퓨터이며,


따라서 길이가 매우 길 수도 있는 수신 메시지를 임시로 저장할 수 있는 충분한 용량의 메모리가 필요하다.


이런 방식에서는 전송 경로에서 다음 기억 장소를 찾고 메시지를 저장하며 재전송하는 데 걸리는 시간으로 인해
지연될 수도 있다.
```

<br>
<br>
<br>

```
<패킷 교환>


패킷 교환은 메시지 교환과 회선 교환의 장점을 서로 결합하고 단점을 최소화시킨 방식이다.


패킷 교환 방식에는 데이터그램 패킷 교환 방식과 가상 회선 패킷 교환 방식이 있다.
```

<br>
<br>

```
><데이터 그램 패킷 교환>
>
>
>데이터 그램 패킷 교환은 각각의 메시지가 어드레스 지정 정보를 갖는 독립적인 단위라는 점에서
>
>
>메시지 교환과 유사하다.
>
>
>이 방식은 다양한 경로를 취할 수 있다는 장점이 있지만, 메시지가 여러 부분으로 나뉘기 때문에
>
>
>서로 다른 경로를 통해 패킷을 전송할 경우 패킷의 순서가 뒤바뀔 수도 있다.
>
>
>따라서 각각의 패킷에 순서를 나타내는 숫자가 추가되어야 한다.
>
>
>데이터그램 패킷 교환은 가장 적절한 경로를 찾아 데이터를 전송하지만,
>
>
>일부 패킷의 경우는 전송중에 지연이 발생할 수도 있으므로 수신 측에서 패킷을 잘못된 순서로 수신할 수 있다.
>
>
>따라서 수신 측에서는 순차번호를 이용해 패킷의 순서를 바로잡아 원래의 메시지를 재구성하게 된다.
>```
>
><br>
><br>
><br>
>
>```
><가상 회선 패킷 교환 방식>
>
>
>송신 측과 수신 측 간의 논리적인 연결을 통해 패킷을 전송하는 방식이다.
>
>
>논리적인 연결은 송신 측과 수신 측이 통신 초기 단계에서 메시지를 교환할 때 형성된다.
>
>
>이 메시지에 의해 수신 측과 송신 측은 최대 메시지 크기, 통신 시 취할 경로,
>
>
>그 밖에 통신을 유지하기 위한 변수 등을 결정한다.
>
>
>일반적으로 가상회선은 연결 지향형 서비스를 의미하며,
>
>
>가상회선은 1회 통신하는 동안만 유지되는 일시적인 것일 수도 있고,
>
>
>송신 측과 수신 측 컴퓨터가 작동하는 동안 계속 유지되는 영구적인 것일 수 도 있다.
>```
>
><br>
><br>
><br>
>
>```
><회선교환과 패킷교환의 차이점>
>
>
>회선교환은 데이터가 전송되기 전에 두 단말장치 간에 회선을 설정하고, 
>
>
>회선이 설정되면 이 회선을 통해 데이터를 전송하며,  
>
>
>일정 시간이 지나면 두 단말장치 중 한 단말장치에 의해 연결이 단절됨
>
>
>회선이 단절되기 전까지 데이터를 전송하지 않을 때에도 다른 단말장치들이
>
>
>이 회선을 이용할 수 없으므로 회선의 이용률면에서는 불리하나 
>
>
>독점적으로 사용되기 때문에 주변의 트래픽이 많다고 회선이 끊어진다든지의 장애는 없다.
>
>
>반면, 패킷 교환 방식은 고정된 경로가 미리 설정되지 않고, 전송은 패킷 단위로 독립적으로 이루어지며,
>
>
>네트워크 트래픽 상태 등에 따라 다른 경로를 가질 수 있다.
>
>
>고정된 경로를 설정하지 않으므로 동일한 경로를 다른 목적지로 가는 여러 패킷들이 공유하여
>
>
>통신회선을 보다 효율적으로 사용가능하다.
>```
>
><br>
><br>
>회선교환
><br>
><br>
><br>
>
>![image](/image/IoT_image/IoT_img_31.png)
>
><br>
><br>
><br>
>패킷교환
><br>
><br>
><br>
>
>![image](/image/IoT_image/IoT_img_32.png)
>
><br>
><br>
><br>
>
>```
><경로 발견>
>
>
>한 노드에서 다른 노드로 패킷을 전송하기 위해 패킷 교환 네트워크나 메시지 교환 네트워크는 
>
>
>각각의 데이터 부분에 대한 올바른 경로를 계속 확인하면서 사용해야 한다.
>
>
>이와 같은 경로 결정 작업을 라우팅이라고 한다.
>
>
>네트워크에서는 데이터를 전송하기 전에 보내고자 하는 목적지까지 패킷이 도착하도록 하기 위해
>
>
>취해야 할 경로를 찾아내야 한다.
>
>
>라우팅 테이블은 패킷이 목적지에 이르기 위해 행해야 하는 
>
>
>다음 홉(패킷이 최종 목적지에 도달하기까지 라우터를 비롯한 기타 네트워크 장치 사이를 경유하는 거리)을
>나타내는 목록을 말한다. 
>
>
>라우팅 테이블에는 네트워크 어드레스, 데이터 경로 내에서의 다음 번 어드레스,
>
>
>그리고 목적지 네트워크에 도착하는데 필요한 자원 등이 포함돼야 한다.
>
>
>이 자원은 라우팅 알고리즘을 이용해 계산되며 다음과 같은 요소로 구성된다.
>
>
>홉 카운트: 목적지 네트워크에 도달하기 위해 데이터가 거쳐야 할 라우터의 개수
>
>
>틱 카운트: 목적지 네트워크에 도달하는 데 소요되는 시간
>
>
>상대적 비용: 특정 경로를 사용하는 데 필요한 비용이나 기타 기준에 기초해 할당할 수 있는 숫자
>```
>
>
><br>
><br>
><br>
>
>```
>경로 발견에는 거리 벡터 방식과 연결 상태 방식 등이 있다.
>
>
><거리 벡터 방식>
>
>
>거리 벡터 라우터는 자신과 동일한 세그먼트에 연결돼 있는 다른 라우터에게 자신의 경로 테이블을
>
>
>컴파일 한 후 전송한다.
>
>
>또한 각각의 라우터는 인접 라우터로부터 전송되는 경로 테이블을 다시 브로드캐스트하거나
>
>
>재구성함으로써 자신의 경로 테이블을 만든다. 
>
>
>따라서 라우터가 전송하는 메시지에는 자신의 경로 테이블 전체가 포함된다.
>```
>
><br>
><br>
><br>
>
>```
><연결 상태 방식>
>
>
>연결 상태 방식의 경우, 라우터는 로컬 라우터로부터 수신한 초기 경로 테이블을 이용해
>
>
>자신이 연결돼있는 네트워크를 식별한다.
>
>
>라우터는 초기화 메시지를 송출한 후, 변경 사항이 발생하게 되면 나머지 라우터에게
>
>
>그 내용을 통보하기만 하면 된다.
>
>
>이 메시지에는 네트워크 세그먼트의 상태에 대한 정보가 포함돼 있어,
>
>
>각각의 라우터가 자신의 정보를 알려주면 수신 장치는 네트워크 어드레스 테이블을 만들게 되는 것이다.
>
>
>보통 다익스트라 알고리즘으로 알려져있다.
>
>
>거리 벡터 알고리즘은 떨어져 있는 네트워크에 대한 정보와 떨어져 있는 라우터들에 대한 특정 지식이 없는데 반하여, 
>
>
>링크상태 알고리즘은 떨어져 있는 라우터들에 대한 모든 지식을 유지하고 어떻게 그들과 연결하는지 알고 있다. 
>```
>
><br>
><br>
><br>
>
>```
><경로 선택>
>
>
>일단 라우팅 테이블을 만든 후에 라우터는 자원 정보를 사용해 인터네트워크를 거치는 최적 경로를 계산할 수 있다.
>
>
>특정 경로를 동적으로 선택하면 라우터는 네트워크의 조건 변화에 맞춰 경로를 조정할 수 있고,
>
>
>정적으로 선택하면 데이터 패킷은 언제나 미리 정해진 경로만을 따라 전달된다.
>```
>
><br>
><br>
><br>
>
>```
><동적 경로 선택>
>
>
>동적 경로 선택은 라우팅 알고리즘을 이용해 계속 자원 정보를 수집하는 것이다.
>
>
>모든 패킷에는 가장 최근의 경로 발견 자원에 따라 경로가 지정되며,
>
>
>네트워크의 특성이 지속적으로 변함에 따라 두 장치 간에 패킷을 전송하는 데는 여러 개의 경로가 사용될 수 있다.
>```
>
><br>
><br>
><br>
>
>```
><정적 경로 선택>
>
>
>정적 선택 방식은 네트워크 관리자나 할당된 네트워크 장치에 의해 지시된 경로를 사용한다.
>
>
>다시 말해 관리자가 직접 라우팅 테이블을 만들거나, 모든 패킷이 특정한 경로를 따라 전달되도록
>컴퓨터가 경로 헤더 정보를 덧붙인다는 것이다.
>
>
>이 때 중간에 있는 라우터는 경로 선택을 결정할 수 없다.
>```
>
><br>
><br>
><br>
>
>```
><연결서비스>
>
>
>데이터링크-LLC 하부 계층 연결 서비스는 두 개의 장치 간에 전송되는 데이터의 양과 유실 또는
>뒤섞인 프레임에 대한 통지를 제어하는 서비스이다.
>
>
>네트워크 계층 서비스는 이런 기능을 바탕으로 그 위에 만들어진 것으로 종종 데이터링크-LLC 연결 서비스를 사용하지 않은 경우
>신뢰성을 확보하기 위해 사용한다.
>
>
>뿐만 아니라, 네트워크 계층 연결 서비스에서도 데이터링크-LLC 하부 계층에서 제공하는 수신 확인과 같은 기능을 사용한다.
>
>
>수신 확인은 네트워크 계층 흐름 제어, 오류 제어, 패킷 순서 제어와 같은 네트워크 연결 서비스를 제공한다.
>
>
>또한 네트워크 계층 연결 서비스는 네트워크 내 임의의 특정 경로를 따라 전송되는 데이터의 양을 제어하고
>
>
>패킷 전달 오류를 검출하며 재전송을 요구, 목적지에서 잘못된 순서로 수신된 패킷의 순서를 재정렬하는 기능을 수행한다.
>```
>
><br>
><br>
><br>
>
>```
><게이트웨이 서비스>
>
>
>독립된 네트워크는 서로 다른 어드레스 지정, 경로 발견, 경로 선택, 연결 서비스 규칙을 사용하는 것이 일반적이다.
>
>
>이런 네트워크를 인터네트워크 환경에서 서로 결합하기 위해서는 네트워크 사이의 차이점을 먼저 해결해야 한다.
>
>
>이 같은 기능은 별개의 두 네트워크 상의 규칙을 해석하고 번역하는 기능을 갖는 게이트웨이에서 구현되는 것이 일반적이다.
>
>
>예를 들면, 두 네트워크는 서로 다른 크기로 데이터 단위를 분할할 수 있다. 
>
>
>네트워크 계층 게이트웨이는 양쪽 네트워크 모두가 수용할 수 있는 크기로 데이터를 분할하거나 재구성하는 역할을 한다.
>```

<br>
<br>

## 전송계층

<br>
<br>

>```
><전송 계층>
>
>
>전송 계층은 복잡한 하위 계층 구조를 상위 계층이 알지 못하도록 감추기 위한 계층이다.
>
>
>여기서는 상위 계층의 메세지를 세그먼트화한 후, 이 세그먼트를 세션 계층이나 상위 계층 프로세스로 신뢰성 있게 전달하는 역할을 한다.
>
>
>전송 계층은 하위 계층에서의 신뢰성이 부족한 연결 서비스나 연결 지향 연결 서비스가 갖는 미비점을 해소하기 위한 역할을 수행한다.
>
>
>만일 어떤 데이터가 수신 측 장치로 올바르게 전달되지 않은 경우, 전송 계층은 재전송을 개시하거나
>
>
>상위 계층에게 이 사실을 통보할 수 이는데, 이에 근거해 상위 계층에서는 필요한 조치를 취하거나 사용자에게 옵션을 제공한다.
>```
>
><br>
><br>
><br>
>
>![image](/image/IoT_image/IoT_img_33.png)
>
><br>
><br>
><br>
>
>```
><어드레스/이름 해석>
>
>
>네트워킹 프로토콜은 사용자에게 영문자와 숫자로 구성된 복잡하거나 외우기 힘든 어드레스 대신,
>일반적인 언어로 된 단순한 이름을 제공한다.
>
>
>어드레스/이름 해석은 이와 같이 알기 쉬운 이름과 원래의 복잡한 어드레스를 식별하거나 대응시키는 기능을 갖는다.
>
>
>네트워크에 연결된 모든 개체가 이 기능을 수행할 수 있으며, 이는 서비스 요구 측 주도와 서비스 제공 측 주도의 두가지 방식으로 수행된다.
>
>
>서비스 요구 측 주도 방식은 각각의 요구 측은 특수한 패킷을 송신하고,
>
>
>서비스 제공 측 주도 방식은 모든 서비스 제공자가 자신의 가용성을 알리는 방송용 패킷을 일정한  간격으로 송신한다.
>```
>
><br>
><br>
><br>
>
>```
><연결 식별자>
>
>
>연결식별자(연결 ID, 포트 또는 소켓)은 각각의 대화를 식별한다. 
>
>
>여기서 말하는 대화는 서비스 제공자와 서비스 요구자와의 대화이다.
>
>
>연결 식별자를 사용할 경우 인쇄 서버 등과 같은 서비스 제공자는 하나 이상의 클라이언트와 동시에 통신할 수 있다.
>
>
>또한 서비스 제공자는 각각의 통신을 수행함에 있어 번호를 참조하며, 다른 하위 계층 번지와의 조정을 위해서는 전송 계층에 의존한다.
>```
>
><br>
><br>
><br>
>
>```
><트랜잭션 식별자>
>
>
>트랜잭션 식별자는 연결 식별자와 비슷하지만, 대화보다는 작은 단위를 뜻한다.
>
>
>즉, 트랜잭션이란 요구와 응답으로 구성된 것을 말한다. 
>
>
>서비스 제공자와 요구자는 대화 전체가 아닌 각 트랜잭션의 출발과 도착을 계속해서 관찰한다.
>```
>
><br>
><br>
><br>
>
>```
><세그먼트 형성>
>
>
>일부 메시지는 네트워크 계층 및 하위 계층이 처리하기 힘들 정도로 크기가 커질 수 있다.
>
>
>뿐만 아니라 상위 계층 메시지 중 일부는 허용 가능한 세그먼트 크기보다 작은 경우도 있을 수 있다.
>
>
>전송 계층에서는 메시지를 세그먼트로 만들어 네트워크의 오버헤드를 줄이는 기능도 수행할 수 있다.
>
>
>그러나 전송 계층에서 사용할 수 있는 메모리의 양이 제한돼 있으며, 일부 세그먼트를 잃어버릴 수 있기 때문에
>
>
>이와 같은 재구성 작업은 상당히 어려운 작업이며, 따라서 전송계층에서는 연결 서비스를 수행하는 경우도 있다.
>```
>
><br>
><br>
><br>
>
>```
><연결 서비스>
>
>
>소프트웨어 엔지니어의 목표와 다른 계층에서 제공되는 연결 서비스에 따라 전송 계층은 신뢰성 있는 종단 간의 연결을 이룰 필요가 있다.
>
>
>경우에 따라서 네트워크 계층뿐 아니라 전송 계층에서도 연결 서비스가 사용된다.
>
>
>연결 서비스에는 세그먼트 순서화, 종단 간 오류 제어, 종단 간 흐름 제어가 있다.
>```

<br>
<br>

## 세션 계층

<br>
<br>

>```
><세션 계층>
>
>
>세션 계층은 전화 교환원이나 전화번호 안내 서비스와 비교할 수 있습니다.
>
>
>예를 들어, 저녁 약속을 위해 레스토랑에 미리 예약을 하고자 하는데, 전화번호를 모른다면
>
>
>전화번호 안내 서비스를 하는 전화 교환원에게 전화를 합니다. 
>
>
>이 교환원은 다른 전화 회사에서 제공된 정보를 사용해 레스토랑의 전화를 찾게 됩니다.
>
>
>이처럼 전화를 알아낸 다음에는 전화 교환원에게 연결을 부탁할 수도 있습니다.
>
>
>이와 마찬가지로 세션 계층에서는 상위 계층에서 필요로 하는 서버 이름과 어드레스를 하위 계층에서 제공되는 논리 어드레스 정보를 사용해서
>
>
>식별할 수 있을 뿐만 아니라, 서비스 제공자와 요청자 간을 연결하고 대화를 하게 할 수 있습니다.
>
>
>이 기능을 수행할 경우 세션 계층은 각 네트워크 구성 요소를 소개하거나 식별해내며 액세스 권한을 조정하기도 한다.
>```
>
><br>
><br>
><br>
>
>![image](/image/IoT_image/IoT_img_34.png)

<br>
<br>

## 프레젠테이션 계층

<br>
<br>

>```
><프레젠테이션 계층>
>
>
>프레젠테이션 계층은 변환과 암호화를 통해 데이터를 주고받는 서로 다른 환경의 컴퓨터와 
>
>
>애플리케이션이 데이터를 이해할 수 있도록 돕는 기능을 수행한다.
>```
>
><br>
><br>
><br>
>
>![image](/image/IoT_image/IoT_img_35.png)

<br>
<br>

## 애플리케이션 계층

<br>
<br>

>```
><애플리케이션 계층>
>
>
>사용자로부터 데이터를 받아 하위 계층으로 전달하고, 하위 계층에서 전달하는 데이터를 사용자에게 전달하는 애플리케이션 계층은
>
>
>여러가지 네트워크 서비스를 제공하는 실질적인 계층이다.
>
>
>애플리케이션 계층에는 각각의 네트워크 서비스에 대한 특정한 주제와 기능이 포함된다.
>
>
>다시 말해, 이 계층 하부에 있는 여섯 계층이 일반적으로 네트워크 서비스를 지원하는 기술과 작업을 포함하는데 반해,
>
>
>애플리케이션 계층에서는 특정 네트워크 서비스 기능을 수행하는데 필요한 프로토콜을 지원한다.
>```
>
><br>
><br>
><br>
>
>![image](/image/IoT_image/IoT_img_36.png)


<br>
<br>
<br>
- - -
이전 장 [[IoT_응용SW기초] 8. 데이터통신 기초(3)](https://kookyungmin.github.io/basis/2018/05/10/basis_08.html)

<br>
<br>
<br>
By 꾸리
